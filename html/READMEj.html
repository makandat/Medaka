<!doctype html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>medaka README</title>
    <!-- BootstrapのCSS読み込み -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body>
<article class="container">
<header>
 <!-- タイトル -->
 <h1 class="text-center p-5 bg-light rounded">Medaka HTTP サーバ v1.2</h1>
 <p class="text-center"><a href="/">HOME</a></p>
 <br>
 <!-- もくじ -->
 <h3 class="text-center">もくじ</h3>
 <div class="row">
  <div class="col-2">
    <ul class="list-unstyled">
     <li><a href="#1 概要">1 概要</a></li>
     <li><a href="#2 機能">2 機能</a>
     <li><a href="#2.1 サポートしているリクエスト">2.1 サポートしているリクエスト</a></li>
     <li><a href="#3 インストール">3 インストール</a></li>
     <li><a href="#4 ビルド">4 ビルド</a></li>
     <li><a href="#5 関連ファイル">5 関連ファイル</a></li>
     <li><a href="#5.1 設定ファイル">5.1 設定ファイル</a></li>
     <li><a href="#5.2 ログファイル">5.2 ログファイル</a></li>
     <li><a href="#5.3 ソースファイル">5.3 ソースファイル</a></li>
     <li><a href="#6 ディレクトリ">6 ディレクトリ</a></li>
     <li><a href="#7 カスタマイズ">7 カスタマイズ</a></li>
     <li><a href="#7.1 medaka.nim">7.1 medaka.nim</a></li>
     <li><a href="#7.2 handlers.nim">7.2 handlers.nim</a></li>
     <li><a href="#8 テンプレートファイル">8 テンプレートファイル</a></li>
     <li><a href="#9 静的ファイル">9 静的ファイル</a></li>
    </ul>
  </div>
  <div class="col">
    <ul class="list-unstyled">
     <li class="fs-4"><a href="#10 proc の解説">10 proc の解説</a></li>
     <li><a href="#10.1 medaka.nim">10.1 medaka.nim</a></li>
     <li><a href="#10.1.1 定数">10.1.1 定数</a></li>
     <li><a href="#readSettings">10.1.2 proc readSettings(): StringTableRef</a></li>
     <li><a href="#initLogger">10.1.3 proc initLogger()</a></li>
     <li><a href="#staticFile">10.1.4 proc staticFile(filepath: string): (HttpCode, string, HttpHeaders)</a></li>
     <li><a href="#callback">10.1.5 proc callback(req: Request) {.async.}</a></li>
     <li><a href="#10.2 medaka_procs.nim">10.2 medaka_procs.nim</a></li>
     <li><a href="#10.2.1 定数">10.2.1 定数</a></li>
     <li><a href="#10.2.2 型">10.2.2 型</a></li>
     <li><a href="#parseQuery">10.2.3 func parseQuery*(query: string): StringTableRef</a></li>
     <li><a href="#getQueryValue">10.2.4 func getQueryValue*(hash: StringTableRef, key: string, default: string): string</a></li>
     <li><a href="#getContentType">10.2.5 func getContentType*(headers: HttpHeaders): string</a></li>
     <li><a href="#parseBody">10.2.6 proc parseBody*(body: string): StringTableRef</a></li>
     <li><a href="#parseJsonBody">10.2.7 proc parseJsonBody*(body: string): JsonNode</a></li>
     <li><a href="#parseArrayBufferBody">10.2.8 func parseArrayBufferBody*(body: string): string</a></li>
     <li><a href="#parseMultipartBody">10.2.9 func parseMultipartBody*(body: string, headers: HttpHeaders): seq[string]</a></li>
     <li><a href="#parseFormDataBody">10.2.10 func parseFormDataBody*(body: string, headers: HttpHeaders): seq[string]</a></li>
     <li><a href="#templateFile">10.2.11 proc templateFile*(filepath: string, args: StringTableRef): (HttpCode, string)</a></li>
     <li><a href="#getMimetype">10.2.12 func getMimetype*(filepath: string): string</a></li>
     <li><a href="#sendFile">10.2.13 proc sendFile*(filepath: string): HandlerResult</a></li>
     <li><a href="#getStValue">10.2.14 func getStValue*(hash: StringTableRef, key:string, default:string=""): string</a></li>
     <li><a href="#is_windows">10.2.15 proc is_windows*(): bool</a></li>
     <li><a href="#getCookies">10.2.16 proc getCookies*(headers: HttpHeaders): StringTableRef</a></li>
     <li><a href="#setCookieValue">10.2.17 proc setCookieValue*(name, value: string, ret_headers: HttpHeaders): HttpHeaders</a></li>
     <li><a href="#removeCookie">10.2.18 proc removeCookie*(name: string, in_headers: HttpHeaders): HttpHeaders</a></li>
     <li><a href="#getCookieValue">10.2.19 proc getCookieValue*(name: string, in_headers: HttpHeaders): string</a></li>
     <li><a href="#getCookieItems">10.2.20 proc getCookieItems*(headers: HttpHeaders): StringTableRef</a></li>
     <li><a href="#setSessionValue">10.2.21 proc setSessionValue*(name:string, value:string, headers:HttpHeaders): string</a></li>
     <li><a href="#getSessionValue">10.2.22 proc getSessionValue*(name: string, headers:HttpHeaders): string</a></li>
     <li><a href="#redirect">10.2.23 proc redirect*(url: string): HandlerResult</a></li>
     <li><a href="#q">10.2.24 func q*(s: string):string</a></li>
     <li><a href="#escapeHtml">10.2.25 func escapeHtml*(s: string): string</a></li>
     <li><a href="#htmlHeader">10.2.26 func htmlHeader*(): HttpHeaders</a></li>
     <li><a href="#textHeader">10.2.27 func textHeader*(): HttpHeaders</a></li>
     <li><a href="#jsonHeader">10.2.28 func jsonHeader*(): HttpHeaders</a></li>
     <li><a href="#octedHeader">10.2.29 func octedHeader*(): HttpHeaders</a></li>
     <li><a href="#10.3 body_parser.nim">10.3 body_parser.nim</a></li>
    </ul>
  </div>
  <div class="col">
    <ul class="list-unstyled">
     <li class="fs-4"><a href="#11 サンプルの解説">11 サンプルの解説</a></li>
     <li><a href="#11.1 medaka.nim">11.1 medaka.nim</a></li>
     <li><a href="#11.2 handlers.nim">11.2 handlers.nim</a></li>
     <li><a href="#/hello">11.2.1 /hello</a></li>
     <li><a href="#/get_query1">11.2.2 /get_query1</a></li>
     <li><a href="#/get_form1">11.2.3 /get_form1 (GET form)</a></li>
     <li><a href="#/post_form2">11.2.4 /post_form2 (POST form)</a></li>
     <li><a href="#/post_form3">11.2.5 /post_form3 (POST multipart form)</a></li>
     <li><a href="#/get_path_param">11.2.6 /get_path_param</a></li>
     <li><a href="#/redirect">11.2.7 /redirect</a></li>
     <li><a href="#/message">11.2.8 /message</a></li>
     <li><a href="#/cookie">11.2.9 /cookie</a></li>
     <li><a href="#/get_medaka_record">11.2.10 /get_medaka_record</a></li>
     <li><a href="#/get_medaka_record2">11.2.11 /get_medaka_record2</a></li>
     <li><a href="#/post_request_json">11.2.12 /post_request_json</a></li>
     <li><a href="#/post_request_formdata">11.2.13 /post_request_formdata</a></li>
     <li><a href="#/post_request_arraybuffer">11.2.14 /post_request_arraybuffer</a></li>
     <li><a href="#/post_request_blob">11.2.15 /post_request_blob</a></li>
     <li><a href="#/post_request_xml">11.2.15 /post_request_xml</a></li>
     <li><a href="#/session">11.2.16 /session</a></li>
     <li><a href="#/cookie_proc">11.2.17/cookie_proc</a></li>
     <li><a href="#/session_proc">11.2.18 /session_proc</a></li>
     <li><a href="#/medaka_db">11.2.19 /medaka_db</a></li>
     <li class="fs-4"><a href="about_cookie.html">12 付録：クッキーについて</a></li>
     <li class="fs-4"><a href="about_request.html">13 付録：リクエストについて</a></li>
    </ul>
  </div>
 </div>
 <br>
</header>

<section class="row">
<div class="fixed-top"><a href="#top">TOP</a></div>
<!-- 1 概要 -->
<h2 class="mt-3"><a id="1 概要">1 概要</a></h2>
<p>"Medaka HTTP Server" は Nim 言語で書かれた HTTP サーバである。</p>
<p>この HTTP サーバは Nim の標準ライブラリに含まれる asynchttpserver をベースとしている。</p>
<p>以下では "Medaka HTTP Server" を単に "Medaka" と呼ぶ。</p>

<!-- 2 機能 -->
<h2 class="mt-3"><a id="2 機能">2 機能</a></h2>
<p>Medaka は以下のような機能を持つ。</p>
<ul>
 <li>HTML ファイルなどの静的なファイルをクライアントへ転送する。</li>
 <li>URL のパスをフックして独自のハンドラを実行する。</li>
 <li>CGI を実行する。(制限あり)</li>
 <li>クッキーを使用可能</li>
 <li>セッション変数を使用可能 (クッキーベース)</li>
 <li>ファイルアップロード</li>
 <li>様々なリクエスト方法をサポート</li>
</ul>

<!--  2.1 サポートしているリクエスト -->
<h3 class="mt-3"><a id="2.1 サポートしているリクエスト">2.1 サポートしているリクエスト</a></h3>
<ul>
 <li>application/x-www-form-urlencoded</li>
 <li>multipart/form-data (FormDataオブジェクトを含む)</li>
 <li>application/json</li>
 <li>application/octed-stream</li>
</ul>

<!-- 3 インストール -->
<h2 class="mt-3"><a id="3 インストール">3 インストール</a></h2>
<p>次のようにしてインストールできる。</p>
<blockquote class="blockquote fs-8">　git clone https://github.com/makandat/Medaka.git</blockquote>

<!-- 4 ビルド -->
<h2 class="mt-3"><a id="4 ビルド">4 ビルド</a></h2>
<p>Medaka フォルダ内で次のコマンドでビルドする。</p>
<ul>
 <li>build.sh medaka (Linux の場合)</li>
 <li>build.ps1 medaka (Windows の場合)</li>
</ul>

<!-- 5 関連ファイル -->
<h2 class="mt-3"><a id="5 関連ファイル">5 関連ファイル</a></h2>
<!--  5.1 設定ファイル -->
<h3 class="mt-1"><a id="5.1 設定ファイル">5.1 設定ファイル</a></h3>
<p>設定ファイルは medaka.json というファイルである。内容はデフォルトで次のようになっている。</p>
<pre class="border rounded p-1"><code>{
  "html":"./html",
  "templates":"./templates",
  "upload":"./upload",
  "cgi-bin":"./cgi-bin",
  "port":"2024",
  "localhost":"false"
}
</code></pre>
<p>(注意) ポート番号、ログファイル名、設定ファイル名はソースを変更しないと変更できない。</p>
<ul>
 <li>html は静的ファイルの場所である。</li>
 <li>templates はテンプレートファイルの場所である。</li>
 <li>upload はアップロードファイルの保存先である。</li>
 <li>cgi-bin は CGI ファイルの場所である。</li>
 <li>port は使用するポート番号である。</li>
 <li>localhost は "true" の場合、http://localhost:port からのみのアクセスに反応する。"false" の場合は、その他のホストからのアクセスも有効になる。</li>
</ul>

<!--  5.2 ログファイル -->
<h3 class="mt-1"><a id="5.2 ログファイル">5.2 ログファイル</a></h3>
<p>ログファイルは "medaka.log" という名前である。</p>

<!--  5.3 ソースファイル -->
<h3 class="mt-1"><a id="5.3 ソースファイル">5.3 ソースファイル</a></h3>
<ul>
 <li>medaka.nim: メインモジュール</li>
 <li>medaka_procs.nim: 関連 proc を集めたモジュール</li>
 <li>handlers.nim: ルートに対応する各ハンドラ用のモジュール</li>
 <li>body_parser.nim: POST メソッドでのリクエストボディを解析するためのモジュール</li>
</ul>


<!-- 6 ディレクトリ -->
<h2 class="mt-3"><a id="6 ディレクトリ">6 ディレクトリ</a></h2>
<ul>
 <li>html: HTML ファイルの場所</li>
 <li>html/css: CSS ファイルの場所</li>
 <li>html/js: JavaScript ファイルの場所</li>
 <li>html/img: 画像ファイルの場所</li>
 <li>templates: HTML テンプレートファイルの場所</li>
 <li>bin: ビルド結果の場所</li>
 <li>cgi-bin: CGI ファイルの場所</li>
</ul>

<!-- 7 カスタマイズ -->
<h2 class="mt-3"><a id="7 カスタマイズ">7 カスタマイズ</a></h2>

<!--  7.1 medaka.nim -->
<h3 class="mt-1"><a id="7.1 medaka.nim">7.1 medaka.nim</a></h2>
<p>proc callback(req: Request) ではディスパッチ処理を行っている。</p>
<p>ここで req.url.path や req.reqMethod を元に呼び出すべきハンドラを決めて、そのハンドラを呼び出す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>#  /hello
if req.url.path == "/hello":
  (status, content, headers) = handlers.get_hello()
</code></pre>
<p>ハンドラは原則としてタプル (HttpCode, string, HttpHeaders) を返す。</p>
<p>タプルの2番目の要素が HTML などである。</p>

<!--  7.2 handlers.nim -->
<h3 class="mt-1"><a id="7.2 handlers.nim">7.2 handlers.nim</h3>
<p>ハンドラはタプル (HttpCode, string, HttpHeaders) を返す必要がある。</p>
<p>パラメータについては特に制限はないが、たいていテンプレートファイルのパスやクエリー文字列などを持つ。</p>
<p>ハンドラは非同期メソッド callback からコールされるのでスレッドセーフである必要がある。</p>

<!-- 8 テンプレートファイル -->
<h2 class="mt-3"><a id="8 テンプレートファイル">8 テンプレートファイル</h2>
テンプレートファイルは HTML とほぼ同じである。</p>
<p>唯一の違いは、埋め込み文字列を表す {{...}} の部分である。</p>
<p>このカッコ自身とカッコ内のシンボルが外部で与えた文字列で置き換えられる。</p>
<p>（注意）{{ }} には制御文を書くことはできない。また、HTML エスケープも行われない。</p>
<p>次にテンプレートファイルの使用例を示す。
<pre class="border rounded p-1"><code>  var hash = parseQuery(query)
  args["id"] = getQueryValue(hash, "id", "")
  args["title"] = getQueryValue(hash, "title", "")
  args["info"] = getQueryValue(hash, "info", "")
  var (status, buff) = templateFile(filepath, args)
  return (status, buff, htmlHeader())
</code></pre>

<!-- 9 静的ファイル -->
<h2 class="mt-3"><a id="9 静的ファイル">9 静的ファイル</h2>
<p>./html フォルダ内のファイルは静的ファイルとして扱われる。静的ファイルとは、HTML ファイル、画像ファイルなどである。</p>
<p>静的ファイルへのアクセスは他のウェブサーバ同様にアクセスできる。また、index.html ファイルはファイル名を指定せずに開くことができる。</p>
<p>次の URL はいずれも index.html を開く。</p>
<ul>
  <li>http://localhost:2024</li>
  <li>http://localhost:2024/</li>
  <li>http://localhost:2024/index.html</li>
</ul>
</section>

<section class="row">
<!-- 10 proc の解説 -->
<h2 class="mt-3"><a id="10 proc の解説">10 proc の解説</a></h2>
<!--  10.1 medaka.nim -->
<h3 class="mt-3"><a id="10.1 medaka.nim">10.1 medaka.nim</a></h3>
<!--   10.1.1 定数 -->
<h4 class="fs-5 mt-2"><a id="10.1.1 定数">10.1.1 定数</a></h4>
<ul class="ms-5">
 <li>const VERSION = "n.n.n"  # バージョン番号</li>
 <li>const USE_PORT:uint16 = 2024 # ポート番号</li>
 <li>const CONFIG_FILE = "medaka.json"  # 設定ファイル</li>
 <li>const LOG_FILE = "medaka.log"  # ログファイル</li>
</ul>
<!--   10.1.2 proc readSettings(): StringTableRef -->
<h4 class="fs-5 mt-2"><a id="readSettings">10.1.2 proc readSettings(): StringTableRef</a></h4>
<p>設定ファイル "medaka.json" を読み込んで StringTableRef を返す。(内部使用)</p>

<!--   10.1.3 proc initLogger() -->
<h4 class="fs-5 mt-2"><a id="initLogger">10.1.3 proc initLogger()</a></h4>
<p>ロガーを初期化して、ログ関数を使用できるように知り。ログの出力先は "medaka.log" である。(内部使用)</p>

<!--   10.1.4 proc staticFile(filepath: string): (HttpCode, string, HttpHeaders) -->
<h4 class="fs-5 mt-2"><a id="staticFile">10.1.4 proc staticFile(filepath: string): (HttpCode, string, HttpHeaders)</a></h4>
<p>filepath で指定した静的ファイルを読み込んでタプル (HttpCode, string, HttpHeaders) を返す。(内部使用)</p>

<!--   10.1.5 proc callback(req: Request) {.async.} -->
<h4 class="fs-5 mt-2"><a id="callback">10.1.5 proc callback(req: Request) {.async.}</a></h4>
<p>メインループからコールされる非同期コールバックプロシージャ。(内部使用)</p>
<p>この proc で req.url.path や req.reqMethod を元にディスパッチ処理を行う。ディスパッチ処理はユーザがカスタマイズを行う。</p>


<!--  10.2 medaka_procs.nim -->
<h3 class="mt-3"><a id="10.2 medaka_procs.nim">10.2 medaka_procs.nim</a></h3>
<p>このモジュールはハンドラを作るときに使用する proc を保有する。</p>
<!--   10.2.1 定数 -->
<h4 class="fs-5 mt-2"><a id="10.2.1 定数">10.2.1 定数</a></h4>
<pre>const SESSION_NAME* = "medaka_session" # セッションのクッキー名</pre>

<!--   10.2.2 型 -->
<h4 class="fs-5 mt-2"><a id="10.2.2 型">10.2.2 型</a></h4>
<pre>type
  HandlerResult* = (HttpCode, string, HttpHeaders)</pre>

<!--   10.2.3 func parseQuery*(query: string): StringTableRef -->
<h4 class="fs-5 mt-2"><a id="parseQuery">10.2.3 func parseQuery*(query: string): StringTableRef</a></h4>
<p>クエリー文字列 (name=value&name=value& ...) をデコードしてキーと値が文字列である辞書に変換する。
<br>なお、query が URL エンコードされている場合、変換後には URL デコードされた文字列となる。</p>
<p>例</p>
<pre class="border rounded p-1"><code>  var hash: StringTableRef = parseQuery("a=Y%20N&b=123.5")
  echo hash["a"]
  echo hash["b"]</code></pre>
<p>結果</p>
<pre class="border rounded p-1">Y N
123.5</pre>

<!--   10.2.4 func getQueryValue*(hash: StringTableRef, key: string, default: string): string -->
<h4 class="fs-5 mt-2"><a id="getQueryValue">10.2.4 func getQueryValue*(hash: StringTableRef, key: string, default: string): string</a></h4>
<p>func parseQuery*(query: string): StringTableRef の結果である StringTableRef 型の hash からキー key に対する値を得る。
hash にキーが存在しない場合は default が値として返される。<br>
この関数は、キーが存在しない可能性がある checkbox 型の値等を得るのに便利である。</p>
<p>例</p>
<pre class="border rounded p-1"><code>    var hash: StringTableRef = parseQuery("a=Y%20N&b=123.5")
    echo hash.getQueryValue("a", "")
    echo hash.getQueryValue("X", "0")</code></pre>
<p>結果</p>
<pre class="border rounded p-1">Y N
0</pre>

<!--   10.2.5 func getContentType*(headers: HttpHeaders): string -->
<h4 class="fs-5 mt-2"><a id="getContentType">10.2.5 func getContentType*(headers: HttpHeaders): string</a></h4>
<p>HttpHeaders 型のパラメータ headers に含まれている Content-Type ヘッダの値を得る。</p>
<p>例</p><pre class="border rounded p-1"><code>    var headers = newHttpHeaders({"content-type":"image/jpeg", "cookie":"XYZ"})
    echo getContentType(headers)</code></pre>
<p>結果</p>
<pre class="border rounded p-1">image/jpeg</pre>


<!--   10.2.6 proc parseBody*(body: string): StringTableRef -->
<h4 class="fs-5 mt-2"><a id="parseBody">10.2.6 proc parseBody*(body: string): StringTableRef</a></h4>
<p>application/x-www-form-urlencoded つまり multipart でないフォームをポストしたときのフォームボディを StringTableRef </p>
<p>例</p><pre class="border rounded p-1"><code>    var body = "key1=Y%20N&key2=-5.84"
    var hash: StringTableRef = parseBody(body)
    echo $hash</code></pre>
<p>結果</p>
<pre class="border rounded p-1">{key1: Y N, key2: -5.84}</pre>

<!--   10.2.7 proc parseJsonBody*(body: string): JsonNode -->
<h4 class="fs-5 mt-2"><a id="parseJsonBody">10.2.7 proc parseJsonBody*(body: string): JsonNode</a></h4>
<p>リクエストの Content-Type が application/json であった場合、body の内容は JSON 形式になる。その場合の body の内容を解析して JsonNode 型の値を返す。</p>
<p>例</p>
<pre class="border rounded p-1"><code>    var body = "{\"x\":5.1, \"y\":-0.7}"
    var jn: JsonNode = parseJsonBody(body)
    echo $jn</code></pre>
<p>結果</p>
<pre class="border rounded p-1">{"x":5.1,"y":-0.7}</pre>

<!--   10.2.8 func parseArrayBufferBody*(body: string): string -->
<h4 class="fs-5 mt-2"><a id="parseArrayBufferBody">10.2.8 func parseArrayBufferBody*(body: string): string</a></h4>
<p>この関数は Content-Type が application/octed-stream の場合に使用すること想定している。
このタイプのデータは純粋なバイナリーデータなので、表示可能なように 16 進数文字列に変換して返す。</p>
<p>例</p>
<pre class="border rounded p-1"><code>    var body = "\x45\x0a\x09\x55"
    var buff = parseArrayBufferBody(body)
    echo buff</code></pre>
<p>結果</p>
<pre class="border rounded p-1">450a0955</pre>

<!--   10.2.9 parseMultipartBody*(body: string, headers: HttpHeaders): seq[string] -->
<h4 class="fs-5 mt-2"><a id="parseMultipartBody">10.2.9 func parseMultipartBody*(body: string, headers: HttpHeaders): seq[string]</a></h4>
<p>この関数はリクエストの Content-Type が multipart/form-data である場合のリクエストボディを解析してフォーム要素を文字列配列として返す。</p>
<p>この文字列配列の要素は、マルチパート境界で分割した dispostion の内容である。</p>
<p>例</p>
<pre class="border rounded p-1"><code>    var headerData = {"accept":"text/html", "content-type":"multipart/form-data; boundary=---------------------------26767473973547735812633686047", "content-length":"618"}
    var headers:HttpHeaders = newHttpHeaders(headerData)
    var body = """-----------------------------26767473973547735812633686047
Content-Disposition: form-data; name="id"

ID
-----------------------------26767473973547735812633686047
Content-Disposition: form-data; name="info"

INFO
-----------------------------26767473973547735812633686047--"""
    var dispos:seq[string] = parseMultipartBody(body, headers)
    for d in dispos:
      echo d</code></pre>
<p>結果</p>
<pre class="border rounded p-1">
Content-Disposition: form-data; name="id"

ID
--

Content-Disposition: form-data; name="info"

INFO
--</pre>

<!--   10.2.10 func parseFormDataBody*(body: string, headers: HttpHeaders): seq[string] -->
<h4 class="fs-5 mt-2"><a id="parseFormDataBody">10.2.10 func parseFormDataBody*(body: string, headers: HttpHeaders): seq[string]</a></h4>
<p>この関数は、クライアントの FormData オブジェクトを含む body を解析して、マルチパート境界でフォームデータを分割した複数文字列を配列として返す。</p>
<p>FormData オブジェクトの Content-Type は multipart/form-data なので、<u>内部では parseMultipartBody 関数を呼び出しているだけである。</u></p>
<p>(例は省略)</p>

<!--   10.2.11 proc templateFile*(filepath: string, args: StringTableRef): (HttpCode, string) -->
<h4 class="fs-5 mt-2"><a id="templateFile">10.2.11 proc templateFile*(filepath: string, args: StringTableRef): (HttpCode, string)</a></h4>
<p>この proc は、テンプレートファイル filepath の埋め込みマーカ ({{...}}) に args のデータを埋め込んだ文字列を返す。</p>
<p>ここで filepath はファイル名でなくフルパス名である。args は StringTableRef 型でキーが埋め込む変数名で値が埋め込む変数の値である。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var filePath = "./templates/form1.html"
    var args = newStringTable({"id":"1", "title":"TITLE", "info":"INFO", "result":"RESULT"})
    var status:HttpCode
    var content:string
    (status, content) = templateFile(filePath, args)
    echo status
    echo content</code></pre>
<p>テンプレートファイル templates/form1.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>medaka get_form1&lt;/title>
 &lt;!-- BootstrapのCSS読み込み -->
 &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
 &lt;style>
.bgcolor {
    background-color: whitesmoke;
    border-radius:6px;
  }
 &lt;/style>
 &lt;script src="./js/JS365Lib.js">&lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="container">
  &lt;h1 class="header-1 bgcolor text-center p-5">medaka get_form1&lt;/h1>
  &lt;p class="text-center fs-5">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="container">
   &lt;section class="row">
    &lt;form name="form1" method="GET" action="/get_form1">
      &lt;div class="mb-3 mt-5 row">
       &lt;div class="col-2">
         &lt;label for="id" class="form-label">Record id&lt;/label>
         &lt;input type="number" id="id" name="id" class="form-control" value="{{id}}" />
       &lt;/div>
      &lt;/div>
      &lt;div class="mb-3 row">
       &lt;div class="col-5">
        &lt;label for="title" class="form-label">Title&lt;/label>
        &lt;input type="text" id="title" name="title" class="form-control" value="{{title}}" />
       &lt;/div>
      &lt;/div>
      &lt;div class="mb-3">
        &lt;label for="info" class="form-label">Info&lt;/label>
        &lt;input type="text" id="info" name="info" class="form-control" value="{{info}}"/>
      &lt;/div>
      &lt;div class="mb-3">
        &lt;input type="submit" class="btn btn-primary" value="送信" />
      &lt;/div>
      &lt;div class="mb-3 form-text">{{result}}&lt;/div>
    &lt;/form>
   &lt;/section>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer class="container">
  &lt;p class="text-center mt-4">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&nbsp;&lt;/p>
 &lt;/footer>
 &lt;!-- BootstrapのJS読み込み -->
 &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.bundle.min.js">&lt;/script>
&lt;/body>
&lt;/html>
</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1"><code>200 OK
&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>medaka get_form1&lt;/title>
 &lt;!-- BootstrapのCSS読み込み -->
 &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
 &lt;style>
.bgcolor {
    background-color: whitesmoke;
    border-radius:6px;
  }
 &lt;/style>
 &lt;script src="./js/JS365Lib.js">&lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="container">
  &lt;h1 class="header-1 bgcolor text-center p-5">medaka get_form1&lt;/h1>
  &lt;p class="text-center fs-5">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="container">
   &lt;section class="row">
    &lt;form name="form1" method="GET" action="/get_form1">
      &lt;div class="mb-3 mt-5 row">
       &lt;div class="col-2">
         &lt;label for="id" class="form-label">Record id&lt;/label>
         &lt;input type="number" id="id" name="id" class="form-control" value="1" />
       &lt;/div>
      &lt;/div>
      &lt;div class="mb-3 row">
       &lt;div class="col-5">
        &lt;label for="title" class="form-label">Title&lt;/label>
        &lt;input type="text" id="title" name="title" class="form-control" value="TITLE" />
       &lt;/div>
      &lt;/div>
      &lt;div class="mb-3">
        &lt;label for="info" class="form-label">Info&lt;/label>
        &lt;input type="text" id="info" name="info" class="form-control" value="INFO"/>
      &lt;/div>
      &lt;div class="mb-3">
        &lt;input type="submit" class="btn btn-primary" value="送信" />
      &lt;/div>
      &lt;div class="mb-3 form-text">RESULT&lt;/div>
    &lt;/form>
   &lt;/section>
 &lt;/article>
 &lt;!-- フッター -->
 &lt;footer class="container">
  &lt;p class="text-center mt-4">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&nbsp;&lt;/p>
 &lt;/footer>
 &lt;!-- BootstrapのJS読み込み -->
 &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.bundle.min.js">&lt;/script>
&lt;/body>
&lt;/html>
</code></pre>

<!--   10.2.12 proc getMimetype*(filepath: string):string -->
<h4 class="fs-5 mt-2"><a id="getMimetype">10.2.12 func getMimetype*(filepath: string): string</a></h4>
<p>この関数は filepath で指定したファイルの拡張子を元に MIME タイプを取得して関数値として返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var mime: string = getMimetype("./templates/form1.html")
    echo mime</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">text/html</pre>

<!--   10.2.13 proc sendFile*(filepath: string, req: Request):HandlerResult -->
<h4 class="fs-5 mt-2"><a id="sendFile">10.2.13 proc sendFile*(filepath: string): HandlerResult</a></h4>
<p>この関数は filepath で指定したファイルを読み込んで、クライアントへレスポンスとして送信できるようにする。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var filePath = "./templates/form1.html"
    var status:HttpCode
    var content:string
    var headers = newHttpHeaders()
    (status, content, headers) = sendFile(filepath)
    echo status
    echo content
    echo headers</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">200 OK
&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 .....
 .....

{"content-type": @["text/html"]}</pre>

<!--   10.2.14 func getStValue*(hash: StringTableRef, key:string, default:string=""): string -->
<h4 class="fs-5 mt-2"><a id="getStValue">10.2.14 func getStValue*(hash: StringTableRef, key:string, default:string=""): string</a></h4>
<p>この関数は StringTable にキーが存在しないときもデフォルト値を返すようにするものである。
つまり、hash にキー key が存在すれば hask[key] を返し、存在しないときは default を関数値として返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var hash = newStringTable({"key1":"value1"})
    echo hash.getStValue("key1", "?1")
    echo hash.getStValue("key0", "?0")</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">value1
?0</pre>

<!--   10.2.15 proc is_windows*(): bool -->
<h4 class="fs-5 mt-2"><a id="is_windows">10.2.15 proc is_windows*(): bool</a></h4>
<p>現在の OS が Windows なら true、そうでないなら false を返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo is_windows()</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">true</pre>

<!--   10.2.16 proc getCookies*(headers: HttpHeaders): StringTableRef -->
<h4 class="fs-5 mt-2"><a id="getCookies">10.2.16 proc getCookies*(headers: HttpHeaders): StringTableRef</a></h4>
<p>リクエストヘッダからクッキー一覧を取り出し、StringTable として返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers: HttpHeaders = newHttpHeaders({"content-type":"multipart/form-data", "cookie":"a=10; b=677"})
    var hash: StringTableRef = getCookies(headers)
    echo $hash</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{b: 677, a: 10}</pre>

<!--   10.2.17 proc setCookieValue*(name, value: string, ret_headers: HttpHeaders): HttpHeaders -->
<h4 class="fs-5 mt-2"><a id="setCookieValue">10.2.17 proc setCookieValue*(name, value: string, ret_headers: HttpHeaders): HttpHeaders</a></h4>
<p>レスポンスヘッダ ret_headers にクッキー (name=value) を追加する。結果としてクッキーが追加された ret_headers を返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers = newHttpHeaders({"content-type":"text/html"})
    var ret_headers = setCookieValue("b", "467", headers)
    echo $ret_headers
    ret_headers = setCookieValue("c", "8", ret_headers)
    echo $ret_headers</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"set-cookie": @["b=467"], "content-type": @["text/html"]}
{"set-cookie": @["b=467", "c=8"], "content-type": @["text/html"]}</pre>

<!--   10.2.18 proc removeCookie*(name: string, in_headers: HttpHeaders): HttpHeaders -->
<h4 class="fs-5 mt-2"><a id="removeCookie">10.2.18 proc removeCookie*(name: string, in_headers: HttpHeaders): HttpHeaders</a></h4>
<p>リクエストヘッダ in_headers のクッキーヘッダ ("cookie: ...") に含まれる name で指定されるクッキーを削除するためのレスポンスヘッダを返す。
クッキーの削除はそのクッキーの Max-Age 属性を 0 にすることにより行う。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers = newHttpHeaders({"content-type":"text/html", "cookie":"a=A, b=BB"})
    var headers2 = removeCookie("a", headers)
    echo $headers2</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"set-cookie": @["a=; max-age=0"]}</pre>

<!--   10.2.19 proc getCookieValue*(name: string, in_headers: HttpHeaders): string -->
<h4 class="fs-5 mt-2"><a id="getCookieValue">10.2.19 proc getCookieValue*(name: string, in_headers: HttpHeaders): string</a></h4>
<p>リクエストヘッダ in_headers にクッキーが含まれる場合、name で指定されたクッキーの値を取得する。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers = newHttpHeaders({"content-type":"text/html", "cookie":"a=A; b=BB"})
    echo getCookieValue("a", headers)
    echo getCookieValue("b", headers)</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">A
BB</pre>

<!--   10.2.20 proc getCookieItems*(headers: HttpHeaders): StringTableRef -->
<h4 class="fs-5 mt-2"><a id="getCookieItems">10.2.20 proc getCookieItems*(headers: HttpHeaders): StringTableRef</a></h4>
<p>この proc は getCookies と同じで、リクエストヘッダ headers に含まれるクッキー一覧を StringTableRef として返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers = newHttpHeaders({"content-type":"text/html", "cookie":"a=A; b=BB"})
    var cookies: StringTableRef = getCookieItems(headers)
    echo cookies</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{b: BB, a: A}</pre>

<!--   10.2.21 proc setSessionValue*(name:string, value:string, headers:HttpHeaders): string -->
<h4 class="fs-5 mt-2"><a id="setSessionValue">10.2.21 proc setSessionValue*(name:string, value:string, headers:HttpHeaders): string</a></h4>
<p>セッション変数はクッキー "medaka_session" の値である。この値は、JSON 形式の文字列で URL エンコードされている。
この proc は JSON データに "name":"value" を追加する。</p>
<p></p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers = newHttpHeaders()
    var session = setSessionValue("x1", "0.5", headers)
    echo session
    headers["cookie"] = SESSION_NAME & "=" & session
    session = setSessionValue("y1", "5.0", headers)
    echo session
    headers["cookie"] = SESSION_NAME & "=" & session.encodeUrl()
    echo headers</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"x1":"0.5"}
{"x1":"0.5","y1":"5.0"}
{"cookie": @["medaka_session=%7B%22x1%22%3A%220.5%22%2C%22y1%22%3A%225.0%22%7D"]}</pre>

<!--   10.2.22 proc getSessionValue*(name: string, headers:HttpHeaders): string -->
<h4 class="fs-5 mt-2"><a id="getSessionValue">10.2.22 proc getSessionValue*(name: string, headers:HttpHeaders): string</a></h4>
<p>この proc はリクエストヘッダのクッキーに "medaka_session" という名前が含まれている場合、そのクッキー値 (JSON 形式) のキーが name であるようなオブジェクト値を返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>    var headers = newHttpHeaders({"cookie":"medaka_session=%7B%22x1%22%3A%220.5%22%2C%22y1%22%3A%225.0%22%7D"})
    echo getSessionValue("x1", headers)
    echo getSessionValue("y1", headers)</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">"0.5"
"5.0"</pre>

<!--   10.2.23 proc redirect*(url: string): HandlerResult -->
<h4 class="fs-5 mt-2"><a id="redirect">10.2.23 proc redirect*(url: string): HandlerResult</a></h4>
<p>この proc は url で指定された URL を開くための HandlerResult を返す。
この proc を実行すると ./templates/redirect.html を使用する。このテンプレートファイルの埋め込み文字列 {{location}} に URL を埋め込むことによりリダイレクトを行う。</p>
<p>./templates/redirect.html の内容は次のようになっている。</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Redirecting ..&lt;/title>
  &lt;link rel="stylesheet" href"/css/style.css">
  &lt;script>
   function onload() {
     location.href = "{{location}}";
   }
  &lt;/script>
 &lt;/head>

 &lt;body onload="onload()">
  &lt;h1>Redirecting ..&lt;/h1>
 &lt;/body>
&lt;/html></code></pre>

<p>(例)</p>
<pre class="border rounded p-1"><code>    var status = Http200
    var content = ""
    var headers = htmlHeader()
    (status, content, headers) = redirect("http://localhost:2024/sample.html")
    echo status
    echo content
    echo headers</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">200 OK
&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Redirecting ..&lt;/title>
  &lt;link rel="stylesheet" href"/css/style.css">
  &lt;script>
   function onload() {
     location.href = "http://localhost:2024/sample.html";
   }
  &lt;/script>
 &lt;/head>

 &lt;body onload="onload()">
  &lt;h1>Redirecting ..&lt;/h1>
 &lt;/body>
&lt;/html>

{"content-type": @["text/html; charset=utf-8"]}</pre>

<!--   10.2.24 func q*(s: string):string -->
<h4 class="fs-5 mt-2"><a id="q">10.2.24 func q*(s: string):string</a></h4>
<p>この関数はパラメータ s を二重引用符で囲んだ文字列を返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo q("Hello World!")</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">"Hello World!"</pre>

<!--   10.2.25 func escapeHtml*(s: string): string -->
<h4 class="fs-5 mt-2"><a id="escapeHtml">10.2.25 func escapeHtml(s: string): string</a></h4>
<p>この関数は '&', '&lt;', '&gt;' をそれぞれ "&amp;amp;", "&amp;lt;", "&amp;gt;" に変換する。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo escapeHtml*("&lt;p&gt;Hello &amp; World&lt;/p&gt;")</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">&amp;lt;p&amp;gt;Hello &amp;amp; World&amp;lt;/p&amp;gt;</pre>

<!--   10.2.26 func htmlHeader*(): HttpHeaders -->
<h4 class="fs-5 mt-2"><a id="htmlHeader">10.2.26 func htmlHeader*(): HttpHeaders</a></h4>
<p>この関数は HTML 用の HTTP ヘッダを返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo htmlHeader()</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"content-type": @["text/html; charset=utf-8"]}</pre>

<!--   10.2.27 func textHeader*(): HttpHeaders -->
<h4 class="fs-5 mt-2"><a id="textHeader">10.2.27 func textHeader*(): HttpHeaders</a></h4>
<p>この関数は テキスト用の HTTP ヘッダを返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo textHeader()</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"content-type": @["text/plain; charset=utf-8"]}</pre>

<!--   10.2.28 func jsonHeader*(): HttpHeaders -->
<h4 class="fs-5 mt-2"><a id="jsonHeader">10.2.28 func jsonHeader*(): HttpHeaders</a></h4>
<p>この関数は JSON 用の HTTP ヘッダを返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo jsonHeader()</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"content-type": @["application/json; charset=utf-8"]}</pre>

<!--   10.2.29 func octedHeader*(): HttpHeaders -->
<h4 class="fs-5 mt-2"><a id="octedHeader">10.2.29 func octedHeader*(): HttpHeaders</a></h4>
<p>この関数は バイナリーデータ用の HTTP ヘッダを返す。</p>
<p>(例)</p>
<pre class="border rounded p-1"><code>echo octedHeader()</code></pre>
<p>(結果)</p>
<pre class="border rounded p-1">{"content-type": @["application/octed-stream"]}</pre>


<!--  10.3 body_parser.nim -->
<h3 class="mt-3"><a id="10.3 body_parser.nim">10.3 body_parser.nim</a></h3>
<p>このモジュールはマルチパートデータの解析に使う proc を持つが、直接、使用するのではなく medaka_procs.nim の proc からコールされる。</p>

<h4 class="fs-5 mt-2"><a id="getBoundary">10.3.1 proc getBoundary*(headers: HttpHeaders): string</a></h4>
<p>HttpHeaders の Content-Type が multipart/form-data の場合、データを分割する境界文字列を取り出して戻り値として返す。</p>

<h4 class="fs-5 mt-2"><a id="getDispositions">10.3.2proc getDispositions*(body: string, boundary: string): seq[string]</a></h4>
<p>Content-Type が multipart/form-data の場合、境界線で分割したそれぞれの部分を配列として返す。</p>

<h4 class="fs-5 mt-2"><a id="isWithChunk">10.3.3 proc isWithChunk*(disposition: string): bool</a></h4>
<p>HttpHeaders の Content-Type が multipart/form-data の場合、分割された部分が

<h4 class="fs-5 mt-2"><a id="getDispositionName">10.3.4 proc getDispositionName*(disposition: string): string</a></h4>
<p>パラメータ disposition で与えた境界線で分割された部分の名前を取得する。</p>

<h4 class="fs-5 mt-2"><a id="getDispositionValue">10.3.5 proc getDispositionValue*(disposition: string): string</a></h4>
<p>パラメータ disposition で与えた境界線で分割された部分の値を取得する。ただし、値がファイルデータではないものとする。</p>

<h4 class="fs-5 mt-2"><a id="getDispositionFileName">10.3.6 proc getDispositionFileName*(disposition: string): string</a></h4>
<p>パラメータ disposition で与えた境界線で分割された部分のファイル名を取得する。ただし、disposition がファイルデータであるものとする。</p>

<h4 class="fs-5 mt-2"><a id="getDispositionChunk">10.3.7 proc getDispositionChunk*(disposition: string): string</a></h4>
<p>パラメータ disposition で与えた境界線で分割された部分のファイルデータを取得する。ただし、disposition がファイルデータであるものとする。</p>

<h4 class="fs-5 mt-2"><a id="body_parser.getValue">10.3.8 proc getValue*(dispositions: seq[string], name:string): string</a></h4>
<p>HttpHeaders の Content-Type が multipart/form-data の場合、境界線で分割された部分の配列 dispositions から名前 name に対応する値を取得する。
ただし、データはファイルデータでないものとする。</p>

<h4 class="fs-5 mt-2"><a id="getChunk">10.3.9 proc getChunk*(dispositions: seq[string], name:string): string</a></h4>
<p>HttpHeaders の Content-Type が multipart/form-data の場合、境界線で分割された部分の配列 dispositions から名前 name に対応する値を取得する。
ただし、データはファイルデータであるものとする。</p>

<h4 class="fs-5 mt-2"><a id="getFileName">10.3.10 proc getFileName*(dispositions: seq[string], name:string): string</a></h4>
<p>HttpHeaders の Content-Type が multipart/form-data の場合、境界線で分割された部分の配列 dispositions から名前 name に対応するファイル名を取得する。
ただし、データはファイルデータであるものとする。</p>

</section>
<br>
<section class="row">
<!-- 11 サンプルの解説 -->
<h2 class="mt-3"><a id="11 サンプルの解説">11 サンプルの解説</a></h2>
<!--  11.1 medaka.nim -->
<h3 class="mt-2"><a id="11.1 medaka.nim">11.1 medaka.nim</a></h3>
<p>medaka.nim の proc callback() はクライアントからのリクエストがあるとコールされる。ここではリクエスト内容を解析して、適切なハンドラをコールしなければならない。
リクエストの内容のうち、req.url.path と req.reqMethod が重要である。</p>
<p>req.url.path は URL のうちポート番号から後ろの部分であり、req.reqMethod はメソッド名である。</p>
<p>例えば、http://localhost:2024/hello という URL の場合、req.url.path は "/hello" になり、req.reqMethod はフォームからのポストでなければ、"GET" となる。</p>
<p>callback() の例を下に示す。/hello より前は静的ファイルと CGI のハンドラであり、変更してはならない。 </p>
<pre class="border rounded p-1"><code>#   TODO: You must change below, when you create your own application.
proc callback(req: Request) {.async.} =
  info(req.url.path)
  echo req.url.path
  var status = Http200
  var content = ""
  var headers = newHttpHeaders({"Content-Type":"text/html; charset=utf-8"})
  let settings = readSettings()
  var filepath = ""
  let htdocs = settings["html"]
  let templates = settings["templates"]
  if req.url.path == "" or req.url.path == "/":
    filepath = htdocs & "/index.html"
  else:
    filepath = htdocs & "/" & req.url.path
  # dispatch handler by method and path
  #   static files
  if req.reqMethod == HttpGet and fileExists(Path(filepath)):
    (status, content, headers) = staticFile(filepath)
  # CGI
  elif req.reqMethod == HttpGet and req.url.path.startsWith("/cgi-bin/"):
    if medaka_procs.is_windows():
      content = "&lt;h1>CGI is not supported on Windows.&lt;/h1>"
      status = Http400
    else:
      try:
        filepath = settings["cgi-bin"] & "/" & req.url.path.substr(len("/cgi-bin/"))
        (status, content) = handlers.execCgi(filepath, req.url.query)
        headers = newHttpHeaders()
        var lines = content.split("\n")
        var i = 0
        while len(lines[i]) > 0:
          var pair = lines[i].split(": ")
          headers[pair[0]] = pair[1]
          i += 1
        content = ""
        i += 1
        while i < len(lines):
          content &= lines[i] & "\n"
          i += 1
      except Exception as e:
        content = e.msg
    await req.respond(status, content, headers)
    return
  #  /hello
  elif req.url.path == "/hello":
    (status, content, headers) = handlers.get_hello()
  #  /get_query1
  elif req.url.path == "/get_query1":
    (status, content, headers) = handlers.get_query1(req.url.query)
  #  /get_form1
  elif req.url.path == "/get_form1":
    filepath = templates & "/form1.html"
    (status, content, headers) = handlers.get_form1(filepath, req.url.query)
  #  /post_form2
  elif req.url.path == "/post_form2":
    filepath = templates & "/form2.html"
    (status, content, headers) = handlers.post_form2(filepath, req.headers, req.body)
  #  /post_form3
  elif req.url.path == "/post_form3":
    filepath = templates & "/form3.html"
    (status, content, headers) = handlers.post_form3(filepath, req.headers, "file1", req.body, settings["upload"])
  #  /get_path_param
  elif req.url.path == "/get_path_param" or req.url.path == "/get_path_param/":
    filepath = templates & "/get_path_param.html"
    (status, content, headers) = handlers.get_path_param(filepath, "", req.headers)
  #  /get_path_param regex
  elif match(req.url.path, re(r"\/get_path_param\/\d+")):
    filepath = templates & "/get_path_param.html"
    (status, content, headers) = handlers.get_path_param(filepath, req.url.path, req.headers)
  #  GET /post_request_json
  elif req.reqMethod == HttpGet and req.url.path == "/post_request_json":
    let filepath = htdocs & "/post_request_json.html"
    (status, content, headers) = staticFile(filepath)
  #  POST /post_request_json
  elif req.reqMethod == HttpPost and req.url.path == "/post_request_json":
    (status, content, headers) = handlers.post_request_json(req.body, req.headers)
  #  GET /post_request_formdata
  elif req.reqMethod == HttpGet and req.url.path == "/post_request_formdata":
    filepath = htdocs & "/post_request_formdata.html"
    (status, content, headers) = staticFile(filepath)
  #  POST /post_request_formdata
  elif req.reqMethod == HttpGet and req.url.path == "/post_request_formdata":
    (status, content, headers) = handlers.post_request_formdata(req.body, req.headers)
  #  GET /post_request_arraybuffer
  elif req.url.path == "/post_request_arraybuffer":
    filepath = htdocs & "/post_request_arraybuffer.html"
    (status, content, headers) = staticFile(filepath)
  # POST /post_request_arraybuffer
  elif req.reqMethod == HttpPost and req.url.path == "/post_request_arraybuffer":
    (status, content, headers) = handlers.post_request_arraybuffer(req.body, req.headers)
  # POST /post_request_blob
  elif req.reqMethod == HttpPost and req.url.path == "/post_request_blob":
    (status, content, headers) = handlers.post_request_blob(req.body)
  #  /redirect
  elif req.url.path == "/redirect":
    filepath = templates & "/redirect.html"
    (status, content, headers) = handlers.get_redirect(req.url.query)
  #  /message
  elif req.url.path == "/message":
    (status, content, headers) = handlers.get_message(req.url.query)
  #  /cookie
  elif req.url.path == "/cookie":
    (status, content, headers) = handlers.get_cookie(req.headers)
  #  /remove_cookies
  elif req.url.path == "/remove_cookie":
    let filepath = htdocs & "/remove_cookie.html"
    (status, content, headers) = staticFile(filepath)
  #  /session
  elif req.reqMethod == HttpGet and req.url.path == "/session":
    echo req.headers
    filepath = templates & "/session.html"
    (status, content, headers) = handlers.post_session(filepath, req.url.query, req.headers)
  elif req.reqMethod == HttpPost and req.url.path == "/session":
    filepath = templates & "/session.html"
    (status, content, headers) = handlers.post_session(filepath, req.body, req.headers)
  #  /get_medaka_record
  elif req.url.path == "/get_medaka_record":
    if req.url.query == "":
      (status, content, headers) = staticFile("./html/get_medaka_record.html")
    else:
      (status, content, headers) = handlers.get_medaka_record(req.url.query)
  #  /get_medaka_record2
  elif req.url.path == "/get_medaka_record2":
    if req.url.query == "":
      filepath = htdocs & "/get_medaka_record2.html"
      (status, content, headers) = staticFile(filepath)
    else:
      (status, content, headers) = handlers.get_medaka_record2(req.url.query)
  # /jump (redirect)
  elif req.url.path == "/jump":
    let kv = medaka_procs.parseQuery(req.url.query)
    (status, content, headers) =  medaka_procs.redirect(kv["url"])
  # /cookie_proc
  elif req.url.path == "/cookie_proc":
    headers = textHeader()
    (content, headers) = handlers.cookie_proc(req.url.query)
  # /session_proc
  elif req.url.path == "/session_proc":
    headers = jsonHeader()
    (content, headers) = handlers.session_proc(req.url.query, req.headers)
  # /sendfile
  elif req.url.path == "/sendfile":
    var kv = parseQuery(req.url.query)
    let filepath = kv["path"]
    (status, content, headers) = medaka_procs.sendfile(filepath)
  # /medaka_db
  elif req.url.path == "/medaka_db":
    content = handlers.medaka_db(settings["templates"])
  else:
    status = Http403 # Forbidden
    headers = newHttpHeaders({"Content-Type":"text/html"})
    content = "<h1>Error: This path is fobidden.</h1><p>" & req.url.path & "</p>"
  await req.respond(status, content, headers)
</code></pre>
<br>

<!--  11.2 handlers.nim -->
<h3 class="mt-2"><a id="11.2 handlers.nim">11.2 handlers.nim</a></h3>
<p>以下に callback() からコールされるハンドラの例を示す。</p>

<!--  11.2.1 /hello -->
<h4 class="fs-5 mt-2"><a id="/hello">11.2.1 /hello ハンドラ</a></h4>
<p>この例は、単純に "Hello World!" という文字を text/plain としてクライアントへ送る。</p>
<pre class="border rounded p-1"><code># hello
proc get_hello*(): HandlerResult =
  result = (Http200, "Hello World!", textHeader())
</code></pre>

<!--  11.2.2 /get_query1 -->
<h4 class="fs-5 mt-2"><a id="/get_query1">11.2.2 /get_query1</a></h4>
<p>この例はテンプレートファイルを使わず、ハンドラ内に HTML を埋め込んで応答として返す。その際、クエリー文字列を HTML に埋め込んでいる。</p>
<pre class="border rounded p-1"><code># get_query1
proc get_query1*(query: string): HandlerResult =
  var html = """&lt;!doctype html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>query1&lt;/title>
 &lt;/head>
 &lt;body>
  &lt;h1 style="text-align:center">query1&lt;/h1>
  &lt;br />
  &lt;h2 style="text-align:center">{{query}}&lt;/h2>
  &lt;p style="text-align:center">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/body>
&lt;/html>
"""
  var content = html.replace("{{query}}", query)
  result = (Http200, content, htmlHeader())</code></pre>

<!--  11.2.3 /get_form1 -->
<h4 class="fs-5 mt-2"><a id="/get_form1">11.2.3 /get_form1</a></h4>
<p>この例はフォームを GET メソッドでサーバに送り、送られてきたクエリー文字列を送り返し表示する。</p>
<pre class="border rounded p-1"><code># get_form1
proc get_form1*(filepath: string, query: string): HandlerResult=
  var args = newStringTable({"result":query})
  if query == "":
    args["id"] = ""
    args["title"] = ""
    args["info"] = ""
  else:
    var hash = parseQuery(query)
    args["id"] = getQueryValue(hash, "id", "")
    args["title"] = getQueryValue(hash, "title", "")
    args["info"] = getQueryValue(hash, "info", "")
  var (status, buff) = templateFile(filepath, args)
  return (status, buff, htmlHeader())</code></pre>

<p>テンプレートファイル ./templates/form1.html</p>
<p><a href="https://github.com/makandat/JS365Lib" target="_blank">JS365Lib.js</a></p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>medaka get_form1&lt;/title>
 &lt;!-- BootstrapのCSS読み込み -->
 &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
 &lt;style>
.bgcolor {
    background-color: whitesmoke;
    border-radius:6px;
  }
 &lt;/style>
 &lt;script src="./js/JS365Lib.js">&lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="container">
  &lt;h1 class="header-1 bgcolor text-center p-5">medaka get_form1&lt;/h1>
  &lt;p class="text-center fs-5">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="container">
   &lt;section class="row">
    &lt;form name="form1" method="GET" action="/get_form1">
      &lt;div class="mb-3 mt-5 row">
       &lt;div class="col-2">
         &lt;label for="id" class="form-label">Record id&lt;/label>
         &lt;input type="number" id="id" name="id" class="form-control" value="{{id}}" />
       &lt;/div>
      &lt;/div>
      &lt;div class="mb-3 row">
       &lt;div class="col-5">
        &lt;label for="title" class="form-label">Title&lt;/label>
        &lt;input type="text" id="title" name="title" class="form-control" value="{{title}}" />
       &lt;/div>
      &lt;/div>
      &lt;div class="mb-3">
        &lt;label for="info" class="form-label">Info&lt;/label>
        &lt;input type="text" id="info" name="info" class="form-control" value="{{info}}"/>
      &lt;/div>
      &lt;div class="mb-3">
        &lt;input type="submit" class="btn btn-primary" value="送信" />
      &lt;/div>
      &lt;div class="mb-3 form-text">{{result}}&lt;/div>
    &lt;/form>
   &lt;/section>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer class="container">
  &lt;p class="text-center mt-4">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
 &lt;!-- BootstrapのJS読み込み -->
 &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.bundle.min.js">&lt;/script>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.4 /post_form2 -->
<h4 class="fs-5 mt-2"><a id="/post_form2">11.2.4 /post_form2</a></h4>
<p>この例はフォームデータをポストして、送られてきたリクエスト内容を送り返して表示する。</p>
<pre class="border rounded p-1"><code># post_form2
proc post_form2*(filepath: string, headers:HttpHeaders, body: string): HandlerResult =
  var s = ""
  for k, v in headers:
    s &= k
    s &= ": "
    for w in v:
      s &= w
    s &= "\n"
  var args = newStringTable({"headers":s, "body":body})
  if body == "":
    args["id"] = ""
    args["name"] = ""
    args["age"] = ""
    args["male"] = "checked"
    args["female"] = ""
  else:
    var hash = parseQuery(body)
    args["id"] = getQueryValue(hash, "id", "")
    args["name"] = getQueryValue(hash, "name", "")
    args["age"] = getQueryValue(hash, "age", "")
    if getQueryValue(hash, "male", "") == "male":
      args["male"] = "checked"
      args["female"] = ""
    else:
      args["male"] = ""
      args["female"] = "checked"
  var (status, buff) = templateFile(filepath, args)
  return (status, buff, htmlHeader())
</code></pre>

<p>テンプレートファイル ./templates/form2.html</p>
<p><a href="https://github.com/makandat/JS365Lib" target="_blank">JS365Lib.js</a></p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>medaka form2&lt;/title>
 &lt;!-- BootstrapのCSS読み込み -->
 &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
 &lt;style>
.bgcolor {
    background-color: whitesmoke;
    border-radius:6px;
  }
 &lt;/style>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="container">
  &lt;h1 class="header-1 bgcolor text-center p-5">medaka post_form2&lt;/h1>
  &lt;p class="text-center fs-4">&lt;a href="/index.html">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="container">
   &lt;form method="POST" action="/post_form2">
    &lt;div class="row mb-3">
     &lt;div class="col-1">
      &lt;label for="id" class="form-label">id&lt;/label>
      &lt;input type="number" class="form-control" name="id" id="id" value="{{id}}">
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
     &lt;div class="col-3">
      &lt;label for="name" class="form-label">name&lt;/label>
      &lt;input type="text" class="form-control" name="name" id="name" value="{{name}}">
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
     &lt;div class="col-1">
      &lt;label for="age" class="form-label">age&lt;/label>
      &lt;input type="number" class="form-control" name="age" id="age" value="{{age}}">
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
     &lt;div class="col-5">
      &lt;input type="radio" class="form-check-input" name="sex" id="male" value="male" {{male}}>
      &lt;label for="male" class="form-check-label">male&lt;/label>
      &lt;input type="radio" class="form-check-input" name="sex" id="female" value="female" {{female}}>
      &lt;label for="female" class="form-check-label">female&lt;/label>
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
      &lt;div class="col-1">
       &lt;input type="submit" class="btn btn-primary" value="送信">
      &lt;/div>
    &lt;/div>
    &lt;h3>headers&lt;/h3>
    &lt;pre class="row mb-3">{{headers}}&lt;/pre>
    &lt;h3>body&lt;/h3>
    &lt;div class="row mb-3">{{body}}&lt;/div>
   &lt;/form>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer class="container">
  &lt;p class="text-center mt-4">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
 &lt;!-- BootstrapのJS読み込み -->
 &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.bundle.min.js">&lt;/script>
&lt;/body>
&lt;/html>
</code></pre>
<!--  11.2.5 /post_form3 -->
<h4 class="fs-5 mt-2"><a id="/post_form3">11.2.5 /post_form3</a></h4>
<p>この例はマルチパートフォームを使って、ファイルをアップロードしている。</p>
<pre class="border rounded p-1"><code># post_form3
proc post_form3*(filepath: string, headers:HttpHeaders, name: string, body: string, upload_folder:string=""): HandlerResult =
  var s = ""
  for k, v in headers:
    s &= k
    s &= ": "
    for w in v:
      s &= w
    s &= "\n"
  var args = newStringTable({"headers":s, "body":body})
  if body != "":
    var disps = parseMultipartBody(body, headers)
    let savefile = upload_folder & "/" & disps.getFileName(name)
    let chunk = disps.getChunk(name)
    writeFile(savefile, chunk)
  var (status, buff) = templateFile(filepath, args)
  return (status, buff, htmlHeader())</code></pre>
<p>テンプレートファイル ./templates/form3.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>medaka form3&lt;/title>
 &lt;!-- BootstrapのCSS読み込み -->
 &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
 &lt;style>
  .bgcolor {
    background-color: whitesmoke;
    border-radius:6px;
  }
  .lines {
    padding: 8px;
    border: solid thin silver;
    border-radius: 6px;
  }
 &lt;/style>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="container">
  &lt;h1 class="header-1 bgcolor text-center p-5">medaka post_form3&lt;/h1>
  &lt;p class="text-center fs-4">&lt;a href="/index.html">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="container">
   &lt;form method="POST" enctype="multipart/form-data" action="/post_form3">
    &lt;div class="row mb-3">
     &lt;div class="col-5">
      &lt;label for="file1" class="form-label">file1&lt;/label>
      &lt;input type="file" class="form-control" name="file1" id="file1">
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
     &lt;div class="col-4">
      &lt;label for="title" class="form-label">title&lt;/label>
      &lt;input type="text" class="form-control" name="title" id="title">
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
     &lt;div class="col-6">
      &lt;label for="info" class="form-label">info&lt;/label>
      &lt;input type="text" class="form-control" name="info" id="info">
     &lt;/div>
    &lt;/div>
    &lt;div class="row mb-3">
      &lt;div class="col-1">
       &lt;input type="submit" class="btn btn-primary" value="送信">
      &lt;/div>
    &lt;/div>
    &lt;h3>headers&lt;/h3>
    &lt;pre class="row mt-4 mb-3 lines">{{headers}}&lt;/pre>
    &lt;h3>body&lt;/h3>
    &lt;pre class="row mt-4 mb-3 lines">{{body}}&lt;/pre>
   &lt;/form>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer class="container">
  &lt;p class="text-center mt-4">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
 &lt;!-- BootstrapのJS読み込み -->
 &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.bundle.min.js">&lt;/script>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.6 /get_path_param -->
<h4 class="fs-5 mt-2"><a id="/get_path_param">11.2.6 /get_path_param</a></h4>
<p>この例ではパスに一部を可変にしてパラメータとして使用するものである。具体的には /get_path_param/number としたパスで number を整数としている。
この整数は SQLite3 データベース medaka.db に含まれる medaka というテーブルの主キーとしてクエリーに使っている。</p>
<pre class="border rounded p-1"><code># get_path_param
proc get_path_param*(filepath:string, path:string, headers:HttpHeaders): HandlerResult =
  var s = ""
  var res = ""
  for k, v in headers:
    s &= k
    s &= ": "
    for w in v:
      s &= w
    s &= "\n"
  let parts = path.split("/")
  var id = 0
  if len(parts) > 2:
    id = parseInt(parts[2])
  let db = db_sqlite.open("./medaka.db", "", "", "")
  let sql: SQLQuery = SQLQuery("SELECT * FROM medaka WHERE id = ?")
  var row:Row = db.getRow(sql, id)
  if row[0] == "":
    res = "Empty"
  else:
    for v in row:
      res &= fmt"{v}, "
      res = res.substr(0, len(res)-2)
  var args = newStringTable({"headers":s, "path":path, "result":res})
  var (status, buff) = templateFile(filepath, args)
  return (status, buff, htmlHeader())
</code></pre>
<p>テンプレートファイル ./templates/get_path_param.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>get_path_param&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function query() {
    const id = getValue("id");
    if (id == "")
      alert("Error: id is empty.");
    else
      location.href = "/get_path_param/" + id;
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header>
  &lt;h1 class="frame">get_path_param&lt;/h1>
  &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;form id="form1" class="form">
    &lt;div class="form-row">
      &lt;label>id &lt;input type="number" id="id" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;button type="button" class="btn" onclick="javascript:query()">送信&lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;h3>Headers&lt;/h3>
  &lt;pre id="headers" class="src">{{headers}}&lt;/pre>
  &lt;h3>Path&lt;/h3>
  &lt;p id="path" class="src">{{path}}&lt;/p>
  &lt;h3>Result&lt;/h3>
  &lt;p id="result" class="message">{{result}}&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.7 /redirect -->
<h4 class="fs-5 mt-2"><a id="/redirect">11.2.7 /redirect</a></h4>
<p>この例はリダイレクトを行うものである。</p>
<pre class="border rounded p-1"><code>proc get_redirect*(query: string): HandlerResult =
  var args = parseQuery(query)
  var (status, buff) = templateFile("./templates/redirect.html", args)
  return (status, buff, htmlHeader())</code></pre>
<p>テンプレートファイル ./templates/</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Redirecting ..&lt;/title>
  &lt;link rel="stylesheet" href"/css/style.css">
  &lt;script>
   function onload() {
     location.href = "{{location}}";
   }
  &lt;/script>
 &lt;/head>

 &lt;body onload="onload()">
  &lt;h1>Redirecting ..&lt;/h1>
 &lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.8 /message -->
<h4 class="fs-5 mt-2"><a id="/message">11.2.8 /message</a></h4>
<p>この例はメッセージを表示するページを開く例である。</p>
<pre class="border rounded p-1"><code># show message page
proc get_message*(query: string): HandlerResult =
  var args = parseQuery(query)
  var (status, buff) = templateFile("./templates/message.html", args)
  return (status, buff, htmlHeader())</code></pre>
<p>テンプレートファイル ./templates/message.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>{{title}}&lt;/title>
  &lt;link href="/css/style.css" rel="stylesheet">
 &lt;/head>
 &lt;body>
  &lt;div class="section">
   &lt;h1>{{title}}&lt;/h1>
   &lt;p style="text-align:center">&lt;a href="/">HOME&lt;/a>&lt;/p>
   &lt;br>
   &lt;p class="message">{{message}}&lt;/p>
  &lt;/div>
 &lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.9 /cookie -->
<h4 class="fs-5 mt-2"><a id="/cookie">11.2.9 /cookie</a></h4>
<p>この例は、リクエストヘッダにクッキーが含まれていれば、それらの一覧を表示する。
また、レスポンスヘッダにクッキー "a=ABC001", "b=bBBbbB" を追加する。</p>
<pre class="border rounded p-1"><code># cookie
proc get_cookie*(headers: HttpHeaders): HandlerResult =
  var args = newStringTable()
  var cookies: StringTableRef = getCookies(headers)
  var ret_headers = htmlHeader()
  if len(cookies) == 0:
    args["result"] = "クッキーがありません。(初回の場合、リロードしてください。)"
    args["list"] = ""
    ret_headers["Set-Cookie"] = @["a=ABC001", "b=bBBbbB"]
  else:
    args["result"] = "クッキーがあります。"
    args["list"] = ""
    for k, v in cookies:
      args["list"] &= li(fmt"{k}={v}")
  var (status, buff) = templateFile("./templates/cookie.html", args)
  return (status, buff, ret_headers)</code></pre>
<p>テンプレートファイル ./templates/cookie.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>cookie&lt;/title>
  &lt;link href="/css/style.css" rel="stylesheet">
 &lt;/head>
 &lt;body>
  &lt;div class="section">
   &lt;h1>cookie&lt;/h1>
   &lt;p style="text-align:center">&lt;a href="/index.html">HOME&lt;/a>&lt;/p>
   &lt;br>
   &lt;ul>
     {{list}}
   &lt;/ul>
   &lt;br>
   &lt;p>{{result}}&lt;/p>
  &lt;/div>
 &lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.10 /get_medaka_record -->
<h4 class="fs-5 mt-2"><a id="/get_medaka_record">11.2.10 /get_medaka_record</a></h4>
<p>この例は SQLite3 データベースの medaka テーブルのレコードを主キーを指定して取得するウェブサービスの使用例である。</p>
<pre class="border rounded p-1"><code># get_medaka_record
proc get_medaka_record*(query: string): HandlerResult =
  var data = parseQuery(query)
  var id = parseInt(getQueryValue(data, "id", "0"))
  let db = db_sqlite.open("./medaka.db", "", "", "")
  var buff: string = ""
  let sql: SQLQuery = SQLQuery("SELECT * FROM medaka WHERE id = ?")
  var row:Row = db.getRow(sql, id)
  if row[0] == "":
    buff = "Empty"
  else:
    for v in row:
      buff &= fmt"{v}, "
      buff = buff.substr(0, len(buff)-2)
  return (Http200, buff, textHeader())</code></pre>
<p>ページファイル ./html/get_medaka_record.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Web service (1) /get_medaka_record as text&lt;/title>
  &lt;link rel="stylesheet" href="/css/style.css">
  &lt;script src="/js/JS365Lib.js">&lt;/script>
  &lt;script>
    function query() {
      getText("/get_medaka_record?id=" + getValue("id"), (text) => {
        setValue("message", text);
      });
    }
  &lt;/script>
 &lt;/head>

 &lt;body>
  &lt;section class="section">
   &lt;h1 class="frame">Web service (1) /get_medaka_record as text&lt;/h1>
   &lt;p style="text-align:center;margin-bottom:10px;">&lt;a href="/">HOME&lt;/a>&lt;/a>&lt;/p>
   &lt;p>Get the record as text of medaka table in SQLite3 medaka.db&lt;/p>
   &lt;form method="GET" class="form">
     &lt;div class="form-row">&lt;label>id &lt;/label>&lt;input type="number" class="form-control" id="id" name="id" size="10" value="1">&lt;/div>
     &lt;div class="form-row">&lt;button type="button" class="btn" onclick="javascript:query()">Query&lt;/button>&lt;/div>
   &lt;/form>
   &lt;div id="message" class="message">&lt;/div>
  &lt;/section>
 &lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.11 /get_medaka_record2 -->
<h4 class="fs-5 mt-2"><a id="/get_medaka_record2">11.2.11 /get_medaka_record2</a></h4>
<p>この例は 11.2.10 と同じく SQLite3 データベースの medaka テーブルのレコードを主キーを指定して取得するウェブサービスの使用例である。</p>
<p>11.2.10 では、レスポンスのタイプは text/plain であるが、この例は JSON (application/json) としてレスポンスを返す。</p>
<pre class="border rounded p-1"><code># get_medaka_record2
proc get_medaka_record2*(query: string): HandlerResult =
  var data = parseQuery(query)
  var id = parseInt(getQueryValue(data, "id", "0"))
  let db = db_sqlite.open("./medaka.db", "", "", "")
  var j: JsonNode
  let sql: SQLQuery = SQLQuery("SELECT * FROM medaka WHERE id = ?")
  var row:Row = db.getRow(sql, id)
  if row[0] == "":
    j = %* {"id":"", "path":"", "method":"", "query":"", "info":""}
  else:
    j = %* {"id":row[0], "path":row[1], "method":row[2], "query":row[3], "info":row[4]}
  return (Http200, $j, jsonHeader())</code></pre>
<p>ページファイル ./html/get_medaka_record2.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Web service (2) /get_medaka_record as JSON&lt;/title>
  &lt;link rel="stylesheet" href="/css/style.css">
  &lt;script src="/js/JS365Lib.js">&lt;/script>
  &lt;script>
    function query() {
      getJSON("/get_medaka_record2?id=" + getValue("id"), (data) => {
         let buff = "&lt;ul>";
         buff += `&lt;li>${data.id}&lt;/li>`;
        buff += `&lt;li>${data.path}&lt;/li>`;
        buff += `&lt;li>${data.method}&lt;/li>`;
        buff += `&lt;li>${data.query}&lt;/li>`;
        buff += `&lt;li>${data.info}&lt;/li>`;
        buff += "&lt;/ul>";
        setValue("message", buff, false);
      });
    }
  &lt;/script>
 &lt;/head>

 &lt;body>
  &lt;section class="section">
   &lt;h1 class="frame">Web service (2) /get_medaka_record as JSON&lt;/h1>
   &lt;p style="text-align:center;;margin-bottom:10px;">&lt;a href="/">HOME&lt;/a>&lt;/a>&lt;/p>
   &lt;p>Get the record as JSON of medaka table in SQLite3 medaka.db&lt;/p>
   &lt;form method="GET" class="form">
     &lt;div class="form-row">&lt;label>id &lt;/label>&lt;input type="number" class="form-control" id="id" name="id" size="10" value="1">&lt;/div>
     &lt;div class="form-row">&lt;button type="button" class="btn" onclick="javascript:query()">Query&lt;/button>&lt;/div>
   &lt;/form>
   &lt;div id="message">&lt;/div>
  &lt;/section>
 &lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.12 /post_request_json -->
<h4 class="fs-5 mt-2"><a id="/post_request_json">11.2.12 /post_request_json</a></h4>
<p>この例は、リクエストデータを JSON (application/json) でポストし、
SQLite3 データベースの medaka テーブルの主キー id で指定したレコードを取得する。
そして、レスポンスとしてそのレコードを JSON (application/json) で返すものである。</p>
<pre class="border rounded p-1"><code># post_request_json
proc post_request_json*(body: string, headers: HttpHeaders): HandlerResult =
  var content = newStringTable()
  var status = Http200
  var res = ""
  var s = ""
  for k, v in headers:
    s &= k
    s &= ": "
    for w in v:
      s &= w
    s &= "\n"
  content["headers"] = s
  content["body"] = body
  content["result"] = ""
  var j = parseJson(body)
  var id = j["id"]
  let db = db_sqlite.open("./medaka.db", "", "", "")
  let sql: SQLQuery = SQLQuery("SELECT * FROM medaka WHERE id = ?")
  var row:Row = db.getRow(sql, id)
  if row[0] == "":
    res = "Empty"
  else:
    for v in row:
      res &= fmt"{v}, "
      res = res.substr(0, len(res)-2)
    content["result"] = res
  var data = %* {"headers":content["headers"], "body":content["body"], "result":content["result"]}
  return (status, $data, jsonHeader())</code></pre>
<p>ページファイル ./html/post_request_json.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>get_request_json&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function query() {
    const id = getValue("id");
    if (id == "")
      alert("id is empty.");
    else
      postJSON("/post_request_json", {"id":parseInt(id), "hidden":0}, (data) => {
          setValue("headers", data["headers"]);
          setValue("body", data["body"]);
          setValue("result", data["result"]);
      });
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header>
  &lt;h1 class="frame">get_request_json&lt;/h1>
   &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;form id="form1" class="form">
    &lt;div class="form-row">
      &lt;label>id &lt;input type="number" id="id" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;button type="button" class="btn" onclick="javascript:query()">送信&lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;h3>Headers&lt;/h3>
  &lt;pre id="headers" class="src">&lt;/pre>
  &lt;h3>Body&lt;/h3>
  &lt;p id="body" class="src">&lt;/p>
  &lt;h3>Result&lt;/h3>
  &lt;p id="result" class="message">&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.13 /post_request_formdata -->
<h4 class="fs-5 mt-2"><a id="/post_request_formdata">11.2.13 post_request_formdata</a></h4>
<p>この例は、SQLite3 データベースの medaka テーブルにレコードを挿入あるいは更新するウェブサービスである。
リクエストデータは FormData オブジェクト (multipart/form-data) として作成する。</p>
<pre class="border rounded p-1"><code># post_request_formdata
proc post_request_formdata*(body: string, headers: HttpHeaders): HandlerResult =
  var status = Http200
  var res = ""
  var s = ""
  for k, v in headers:
    s &= k
    s &= ": "
    for w in v:
      s &= w
    s &= "\n"
  var disps = parseMultipartBody(body, headers)
  var rslt: JsonNode
  var id = disps.getValue("id")
  let path = disps.getValue("path")
  let methods = disps.getValue("methods")
  let query = disps.getValue("query")
  let info = disps.getValue("info")
  var sql: string
  let db = db_sqlite.open("./medaka.db", "", "", "")
  if id == "0":
    # Insert
    sql = "INSERT INTO medaka VALUES(NULL, ?, ?, ?, ?)"
    db.exec(SqlQuery(sql), path, methods, query, info)
    rslt = %* {"result":"Inserted", "headers":s, "body":body}
  else:
    # Update
    sql = "UPDATE medaka SET path=?, methods=?, query=?, info=? WHERE id=?"
    db.exec(SqlQuery(sql), path, methods, query, info, parseInt(id))
    rslt = %* {"result":"Updated", "headers":s, "body":body}
  db.close()
  return (Http200, $rslt, jsonHeader())</code></pre>
<p>ページファイル ./html/post_request_formdata.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>post_request_formdata&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function query1() {
    const formData = new FormData(form1);
    postFormData("/post_request_formdata", formData, (data) => {
      setValue("headers", data["headers"]);
      setValue("body", data["body"]);
      setValue("result", data["result"]);
    });
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="frame section">
  &lt;h1>post_request_formdata&lt;/h1>
   &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;br>
  &lt;form id="form1" name="form1" class="form">
    &lt;div class="form-row">
      &lt;label>id&lt;br>&lt;input type="text" id="id" name="id" value="0" class="form-control"> (If 0 then insert else update)&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;label>path&lt;br>&lt;input type="text" id="path" name="path" size="50" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;label>methods&lt;br>&lt;input type="text" id="methods" name="methods" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;label>query&lt;br>&lt;input type="text" id="query" name="query" size="50" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;label>info&lt;br>&lt;input type="text" id="info" name="info" size="80" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;button type="button" class="btn" onclick="javascript:query1()">&nbsp;&nbsp;送信&nbsp;&nbsp;&lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;h3>Headers&lt;/h3>
  &lt;pre id="headers" class="src">&lt;/pre>
  &lt;h3>Body&lt;/h3>
  &lt;p id="body" class="src">&lt;/p>
  &lt;h3>Result&lt;/h3>
  &lt;p id="result" class="message">&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.14 /post_request_arraybuffer -->
<h4 class="fs-5 mt-2"><a id="/post_request_arraybuffer">11.2.14 /post_request_arraybuffer</a></h4>
<pre class="border rounded p-1"><code># post_request_arraybuffer
proc post_request_arraybuffer*(body: string, headers: HttpHeaders): HandlerResult =
  if headers["content-type"] == "application/octed-stream":
    return (Http200, body, octedHeader())
  raise</code></pre>
<p>ページファイル ./html/post_request_arraybuffer.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>post_request_arraybuffer&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function sendData() {
    let bdata = getValue("data");
    const url = "/post_request_arraybuffer";
    const request = new Request(url, {
      method:"POST",
      body:bdata,
    });
    request.arrayBuffer()
    .then(data => {
      setValue("length", data.byteLength);
      const view = new Uint8Array(data);
      setValue("body", view.toString());
    });
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="frame section">
  &lt;h1>post_request_arraybuffer&lt;/h1>
   &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;br>
  &lt;form id="form1" name="form1" class="form">
    &lt;div class="form-row">
      &lt;label>data&lt;br>&lt;input type="text" id="data" size="100" value="ABC 012" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;button type="button" class="btn" onclick="javascript:sendData()">&amp;nbsp;&amp;nbsp;送信&amp;nbsp;&amp;nbsp;&lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;h3>Byte length&lt;/h3>
  &lt;p id="length" class="src">&lt;/p>
  &lt;h3>Body&lt;/h3>
  &lt;p id="body" class="src">&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.15 /post_request_blob -->
<h4 class="fs-5 mt-2"><a id="/post_request_blob">11.2.15 /post_request_blob</a></h4>
<p>この例は、path で指定したテキストファイルをポストフェッチでリクエストを送り、 BLOB としてダウンロードして、その内容を表示する。</p>
<pre class="border rounded p-1"><code># post_request_blob
proc post_request_blob*(body: string): HandlerResult =
  var status = Http200
  var ret_headers = newHttpHeaders({"content-type": "text/plain; charset=utf-8"})
  var args = medaka_procs.parseQuery(body)
  echo args["path"]
  let rstrm = newFileStream(args["path"], fmRead)
  var content = rstrm.readAll()
  rstrm.close()
  return (status, content, ret_headers)</code></pre>
<p>HTML ファイル ./html/post_request_blob.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>post_request_blob&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function query() {
    let path = getValue("path");
    if (path == "")
      alert("id is empty.");
    else
      if (path.startsWith('"'))
        path = path.substring(1, path.length - 1)
      path = path.replaceAll("\\", "/")
      fetchBLOB("/post_request_blob", {"path":path}, "POST", "text", (data) => {
          setValue("result", data);
      });
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header>
  &lt;h1 class="frame">post_request_blob&lt;/h1>
   &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;form id="form1" name="form1" class="form">
    &lt;div class="form-row">
      &lt;label>path (Text file)&lt;br>&lt;input type="text" id="path" name="path" class="form-control" size="100">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;button type="button" class="btn" onclick="javascript:query()"> 送信 &lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;h3>Result&lt;/h3>
  &lt;p id="result" style="font-size:small;">&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>


<!--  11.2.16 /post_request_xml -->
<h4 class="fs-5 mt-2"><a id="/post_request_xml">11.2.16 /post_request_xml</a></h4>
<pre class="border rounded p-1"><code># post_request_xml
proc post_request_xml*(body: string, headers: HttpHeaders): HandlerResult =
  if headers["content-type"] == "application/xml":
    var hs = ""
    for k, v in headers:
      hs &= k
      hs &= ": "
      for w in v:
        hs &= w
      hs &= "\n"
    var xn:XmlNode = parseXml(body)
    var s = ""
    for item in xn.items:
      s.add('"' & item.tag & '"' & ':' & '"' & item.innerText() & '"' & ',')
    s = '{' & s.substr(0, len(s)-2) & '}'
    var content = %* {"headers":hs, "body":body, "result":s}
    return (Http200, $content, jsonHeader())
  else:
    raise</code></pre>
<p>HTML ファイル ./html/post_request_xml.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>post_request_xml&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function sendXml() {
    const id = getValue("id");
    if (id == "")
      alert("id is empty.");
    else {
      const name = getValue("name");
      let xmldata = `&lt;data>&lt;id>${id}&lt;/id>&lt;name>${name}&lt;/name>&lt;/data>`;
      postXml("/post_request_xml", xmldata, (data) => {
          setValue("headers", data["headers"]);
          setValue("body", data["body"]);
          setValue("result", data["result"]);
      });
    }
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header>
  &lt;h1 class="frame">post_request_xml&lt;/h1>
   &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;form id="form1" class="form">
    &lt;div class="form-row">
      &lt;label>id&lt;br>&lt;input type="number" id="id" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;label>name&lt;br>&lt;input type="name" id="name" size="60" class="form-control">&lt;/label>
    &lt;/div>
    &lt;div class="form-row">
      &lt;button type="button" class="btn" onclick="javascript:sendXml()">送信&lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;h3>Headers&lt;/h3>
  &lt;pre id="headers" class="src">&lt;/pre>
  &lt;h3>Body&lt;/h3>
  &lt;p id="body" class="src">&lt;/p>
  &lt;h3>Result&lt;/h3>
  &lt;p id="result" class="message">&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&nbsp;&lt;/p>
  &lt;p>&nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html></code></pre>


<!--  11.2.17 /session -->
<h4 class="fs-5 mt-2"><a id="/session">11.2.17 /session</a></h4>
<pre class="border rounded p-1"><code># session
proc post_session*(filepath: string, body: string, headers: HttpHeaders): HandlerResult =
  var args = newStringTable()
  var cookies = getCookies(headers)
  var jn:JsonNode = %* {}
  var session = ""
  if cookies.hasKey(SESSION_NAME):
    session = decodeUrl(cookies[SESSION_NAME])
    if session != "":
      try:
        jn = parseJson(session)
      except:
        jn = %* {}
  if body != "":
    var param = parseBody(body)
    let name = param.getStValue("name")
    let value = param.getStValue("value")
    let remove = param.getStValue("remove")
    if remove == "":
      jn[name] = %value
    else:
      jn.delete(name)
    session = encodeUrl($jn)
  var ret_headers: HttpHeaders = htmlHeader()
  ret_headers["Set-Cookie"] = SESSION_NAME & "=" & session
  args["sessionList"] = decodeUrl(session)
  let (status, content) = templateFile(filepath, args)
  return (status, content, ret_headers)</code></pre>
<p>テンプレートファイル ./templates/session.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>session&lt;/title>
  &lt;link rel="stylesheet" href="/css/style.css">
 &lt;/head>

 &lt;body>
  &lt;section class="section">
   &lt;h1 class="frame">session&lt;/h1>
   &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
   &lt;br />
   &lt;h4>Add/Remove session variables&lt;/h4>
   &lt;form class="form" id="form1" name="form1" method="POST" action="/session">
     &lt;div class="form-row">&lt;label>
       &lt;input type="checkbox" name="remove" id="remove" value="remove" class="form-control"> remove
     &lt;/label>&lt;/div>
     &lt;div class="form-row">&lt;label>name&lt;br>
       &lt;input type="text" name="name" id="name" class="form-control">
     &lt;/label>&lt;/div>
     &lt;div class="form-row">&lt;label>value&lt;br>
       &lt;input type="text" name="value" id="value" size="50" class="form-control">
     &lt;/label>&lt;/div>
     &lt;div class="form-row">
       &lt;button type="submit" id="execute" class="btn">&nbsp;&nbsp;Execute&nbsp;&nbsp;&lt;/button>
     &lt;/div>
   &lt;/form>
   &lt;br>
   &lt;div class="message" id="sessionList">{{sessionList}}&lt;/div>
  &lt;/section>
 &lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.18 /cookie_proc -->
<h4 class="fs-5 mt-2"><a id="/cookie_proc">11.2.18 /cookie_proc</a></h4>
<pre class="border rounded p-1"><code># /cookie_proc
proc cookie_proc*(query:string): (string, HttpHeaders) =
  var kv = parseQuery(query)
  var name = kv["cpname"]
  var value = kv["cpvalue"]
  var ret_headers = textHeader()
  ret_headers = setCookieValue(name, value, ret_headers)
  var content = name & "=" & value
  return (content, ret_headers)</code></pre>
<p>ページファイル ./templates/cookie_proc.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>cookie_proc&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function button1_click() {
    let name1 = getValue("cpname");
    let value1 = getValue("cpvalue");
    fetchText("/cookie_proc", { "cpname":name1, "cpvalue":value1 }, "GET", (data) => {
       setValue("message", data);
    });
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="section">
  &lt;h1>cookie_proc&lt;/h1>
  &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;form class="form" name="form1">
    &lt;div class="form-row">
     &lt;label>name&lt;br>
      &lt;input type="text" id="cpname" name="cpname" class="form-control" size="40">
     &lt;/label>
    &lt;/div>
    &lt;div class="form-row">
     &lt;label>value&lt;br>
      &lt;input type="text" id="cpvalue" name="cpvalue" class="form-control" size="80">
     &lt;/label>
    &lt;/div>
    &lt;div class="form-row">
     &lt;label>
      &lt;input type="checkbox" id="remove" name="remove" class="form-control"> remove
     &lt;/label>
    &lt;/div>
    &lt;div class="form-row2">
     &lt;button type="button" class="btn-b" id="button1" onclick="button1_click()"> Add / Update &lt;/button>
    &lt;/div>
  &lt;/form>
  &lt;br>
  &lt;div class="message" id="message">&lt;/div>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.19 /session_proc -->
<h4 class="fs-5 mt-2"><a id="/session_proc">11.2.19 /session_proc</a></h4>
<pre class="border rounded p-1"><code># /session_proc
proc session_proc*(query:string, headers:HttpHeaders): (string, HttpHeaders) =
  var kv = parseQuery(query)
  var ret_headers = newHttpHeaders()
  if kv.hasKey("name") and kv.hasKey("value"):
    var session = setSessionValue(kv["name"], kv["value"], headers)
    ret_headers["Set-Cookie"] = SESSION_NAME & "=" & session.encodeUrl()
    return (session, ret_headers)
  else:
    return ("{\"error\":\"no name\"}", ret_headers)</code></pre>
<p>ページファイル ./templates/session_proc.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>session_proc&lt;/title>
 &lt;link rel="stylesheet" href="/css/style.css" />
 &lt;script src="/js/JS365Lib.js">&lt;/script>
 &lt;script>
  function button1_click() {
    let name1 = getValue("name");
    let value1 = getValue("value").replaceAll("+", "%2b");
    fetchText("/session_proc", { "name":name1, "value":value1 }, "GET", (data) => {
       let data1 = decodeURI(data)
       let data2 = JSON.stringify(data1).replaceAll("\"", "").replaceAll("\\", "\"");
       setValue("message", data2);
    });
  }
 &lt;/script>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="section">
  &lt;h1>session_proc&lt;/h1>
  &lt;p style="text-align:center;">&lt;a href="/">HOME&lt;/a>&lt;/p>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="section">
  &lt;br>
  &lt;form class="form" id="form1">
   &lt;div class="form-row">
    &lt;label>name&lt;br>
     &lt;input type="text" id="name" class="form-control">
    &lt;/label>
   &lt;/div>
   &lt;div class="form-row">
    &lt;label>value&lt;br>
     &lt;input type="text" id="value" size="80" class="form-control">
    &lt;/label>
   &lt;/div>
   &lt;div class="form-row2">
    &lt;button class="btn-b" type="button" id="button1" onclick="button1_click()"> Add / Update &lt;/button>
   &lt;/div>
  &lt;/form>
  &lt;br>
  &lt;p class="message" id="message">&lt;/p>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p style="text-align:center;">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
  &lt;p>&amp;nbsp;&lt;/p>
 &lt;/footer>
&lt;/body>
&lt;/html>
</code></pre>

<!--  11.2.20 /medaka_db -->
<h4 class="fs-5 mt-2"><a id="/medaka_db">11.2.20 /medaka_db (テーブルの内容一覧)</a></h4>
<pre class="border rounded p-1"><code># /medaka_db
proc medaka_db*(`template`: string): string =
  var args = newStringTable()
  let db = db_sqlite.open("./medaka.db", "", "", "")
  var medaka_table = ""
  for x in db.fastRows(sql"SELECT * FROM medaka"):
    var row = ""
    row = tr(td(x[0]) & td(x[1]) & td(x[2]) & td(x[3]) & td(x[4]))
    medaka_table &= row
  args["medaka_table"] = medaka_table
  var nimble_table = ""
  for x in db.fastRows(sql"SELECT * FROM nimble"):
    var row = ""
    row = tr(td(x[0]) & td(x[1]) & td(x[2]) & td(x[3]))
    nimble_table &= row
  args["nimble_table"] = nimble_table
  let filepath = `template` & "/medaka_db.html"
  return templateFile(filepath, args)[1]</code></pre>
<p>テンプレートファイル ./templates/medaka_db.html</p>
<pre class="border rounded p-1"><code>&lt;!DOCTYPE html>
&lt;html lang="ja">
&lt;head>
 &lt;meta charset="utf-8" />
 &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
 &lt;title>database_medaka&lt;/title>
 &lt;!-- BootstrapのCSS読み込み -->
 &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
 &lt;style>
.bgcolor {
    background-color: whitesmoke;
    border-radius:6px;
  }
 &lt;/style>
&lt;/head>

&lt;body>
 &lt;!-- ヘッダー -->
 &lt;header class="container">
  &lt;h1 class="header-1 bgcolor text-center p-5">database_medaka&lt;/h1>
  &lt;p class="text-center">&lt;a href="/index.html">HOME&lt;/a>&lt;/h1>
 &lt;/header>

 &lt;!-- 本文 -->
 &lt;article class="container">
   &lt;section class="row">
    &lt;h2>medaka table&lt;/h2>
    &lt;table class="table table-striped">
     &lt;tr>&lt;th>id&lt;/th>&lt;th>path&lt;/th>&lt;th>methods&lt;/yh>&lt;th>query&lt;/th>&lt;th>info&lt;/th>&lt;/tr>
     {{medaka_table}}
    &lt;/table>
   &lt;/section>
   &lt;br>
   &lt;section class="row">
    &lt;h2>nimble table&lt;/h2>
    &lt;table class="table table-striped">
     &lt;tr>&lt;th>id&lt;/th>&lt;th>package&lt;/th>&lt;th>installed&lt;/th>&lt;th>info&lt;/th>&lt;/tr>
      {{nimble_table}}
    &lt;/table>
   &lt;/section>
 &lt;/article>

 &lt;!-- フッター -->
 &lt;footer class="container">
  &lt;p class="text-center mt-4">&lt;a href="#top">TOP&lt;/a>&lt;/p>
  &lt;p>&nbsp;&lt;/p>
 &lt;/footer>
 &lt;!-- BootstrapのJS読み込み -->
 &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.bundle.min.js">&lt;/script>
&lt;/body>
&lt;/html>
&lt;/code>&lt;/pre>

&lt;/section>

&lt;footer class="row mt-5 mb-5">
  &lt;p class="text-center">&lt;a href="#top">TOP&lt;/a>&lt;/p>
&lt;/footer>
&lt;/article>
&lt;/body>
&lt;/html>
</code></pre>
</section>

<!-- footer -->
<footer>
<p>&nbsp;</p>
<p class="text-center"><a href="#top">TOP</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</footer>
</body>
</html>
